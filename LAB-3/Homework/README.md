# 多執行緒 TCP 聊天室系統

## 學生資料

- **課程** 1141 網路程式設計實習(資訊三合)[1402]
- **班級** 資訊三乙
- **姓名** 王建葦
- **學號** D1210799

## 專案概述

這是一個基於 TCP 協定的多執行緒聊天室系統，支援多個聊天室和最多 5 個同時連線的客戶端。系統使用 pthread 實現多執行緒處理，確保多個客戶端可以同時進行聊天。

## 系統架構

- **伺服器端 (Server.c)**: 多執行緒 TCP 伺服器，管理客戶端連線和訊息廣播
- **客戶端 (Client.c)**: TCP 客戶端，支援加入不同聊天室和即時訊息接收

## 功能特色

### 1. 聊天室管理
- 支援三個聊天室：RoomA、RoomB、RoomC
- 客戶端可以選擇加入指定聊天室
- 客戶端可以隨時切換聊天室

### 2. 客戶端管理
- 最多支援 5 個同時連線的客戶端
- 當第 6 個客戶端嘗試連線時，伺服器會拒絕並顯示「Server is full!」
- 動態處理客戶端的連線和斷線

### 3. 訊息廣播
- 同一個聊天室內的客戶端可以互相看到訊息
- 不同聊天室之間的訊息互相隔離
- 伺服器會廣播客戶端加入/離開聊天室的通知

### 4. 執行緒安全
- 使用 pthread_mutex 確保共享資源的執行緒安全
- 每個客戶端連線使用獨立的執行緒處理

## 編譯與執行

### 編譯
使用提供的編譯腳本：
```bash
chmod +x Compile.sh
./Compile.sh
```

或手動編譯：
```bash
gcc -pthread -o server Server.c
gcc -pthread -o client Client.c
```

### 執行

1. **啟動伺服器**：
```bash
./server
```
伺服器將在 `127.0.0.1:8080` 上監聽連線

2. **啟動客戶端**：
```bash
./client
```
客戶端將連線到伺服器並顯示可用指令

## 使用說明

### 客戶端指令

1. **加入聊天室**：
   - `enter A` - 加入 RoomA
   - `enter B` - 加入 RoomB  
   - `enter C` - 加入 RoomC

2. **離開聊天室**：
   - `EXIT!` - 斷開連線並離開

3. **聊天**：
   - 直接輸入文字訊息即可在同一個聊天室內廣播

### 系統行為

1. **新客戶端加入**：
   - 客戶端預設加入 RoomA
   - 伺服器會通知同一個聊天室的其他客戶端有新成員加入

2. **切換聊天室**：
   - 使用 `enter` 指令可以隨時切換聊天室
   - 切換後會收到確認訊息
   - 新聊天室的其他成員會收到加入通知

3. **訊息隔離**：
   - 只有同一個聊天室的客戶端可以看到彼此的訊息
   - 伺服器廣播訊息（如加入/離開通知）所有客戶端都能看到

4. **連線限制**：
   - 當伺服器達到最大連線數（5個）時，新客戶端會被拒絕
   - 被拒絕的客戶端會收到「Server is full!」訊息並自動關閉

## 技術實作

### 伺服器端 (Server.c) 細部運作

#### 全域變數與資料結構
```c
int client_sockets[MAX_CLIENTS];     // 儲存所有客戶端的 socket
char client_rooms[MAX_CLIENTS][10];  // 儲存每個客戶端所在的聊天室
pthread_mutex_t lock;                // 執行緒鎖，保護共享資源
```

#### 核心函數運作流程

**1. broadcast_message() 函數**
```c
void broadcast_message(const char *msg, int sender_index, const char *room)
```
- **功能**: 向同一個聊天室內的所有客戶端廣播訊息（除了發送者）
- **運作流程**:
  1. 使用 `pthread_mutex_lock()` 鎖定共享資源
  2. 遍歷所有客戶端 socket
  3. 檢查客戶端是否在指定聊天室且不是發送者
  4. 向符合條件的客戶端發送訊息
  5. 使用 `pthread_mutex_unlock()` 釋放鎖

**2. broadcast_server() 函數**
```c
void broadcast_server(const char *msg)
```
- **功能**: 向所有連線的客戶端廣播伺服器訊息
- **運作流程**:
  1. 鎖定共享資源
  2. 遍歷所有有效的客戶端 socket
  3. 向每個客戶端發送伺服器訊息
  4. 釋放鎖

**3. client_handler() 函數**
```c
void *client_handler(void *arg)
```
- **功能**: 處理單一客戶端的所有操作
- **運作流程**:
  1. **初始化階段**:
     - 取得客戶端 socket 和索引
     - 預設將客戶端分配到 RoomA
     - 廣播新客戶端加入訊息
  
  2. **訊息處理迴圈**:
     - 使用 `recv()` 接收客戶端訊息
     - 檢查連線狀態（len <= 0 表示斷線）
     - 處理特殊指令：
       - `EXIT!`: 廣播離開訊息並結束處理
       - `enter A/B/C`: 切換聊天室並廣播通知
       - 一般訊息: 格式化後廣播給同聊天室成員
  
  3. **清理階段**:
     - 關閉 socket
     - 清除客戶端記錄
     - 結束執行緒

**4. main() 函數**
```c
int main()
```
- **運作流程**:
  1. **伺服器初始化**:
     - 建立 socket (`socket()`)
     - 設定伺服器位址 (`bind()`)
     - 開始監聽 (`listen()`)
     - 初始化互斥鎖 (`pthread_mutex_init()`)
  
  2. **客戶端連線處理迴圈**:
     - 接受新連線 (`accept()`)
     - 檢查是否達到最大連線數 (5個)
     - 如果未滿：分配索引、建立處理執行緒
     - 如果已滿：發送 "Server is full!" 並關閉連線

#### 執行緒安全機制
- 使用 `pthread_mutex_t lock` 保護所有共享資源存取
- 確保 `client_sockets[]` 和 `client_rooms[]` 陣列的執行緒安全
- 每個客戶端連線使用獨立的執行緒處理，避免阻塞

### 客戶端 (Client.c) 細部運作

#### 全域變數
```c
int sock;  // 與伺服器連線的 socket
```

#### 核心函數運作流程

**1. receive_handler() 函數**
```c
void *receive_handler(void *arg)
```
- **功能**: 持續監聽伺服器訊息並顯示
- **運作流程**:
  1. 進入無限迴圈
  2. 使用 `recv()` 接收伺服器訊息
  3. 檢查連線狀態（len <= 0 表示斷線）
  4. 將接收到的訊息顯示在螢幕上
  5. 使用 `fflush(stdout)` 確保即時顯示

**2. main() 函數**
```c
int main()
```
- **運作流程**:
  1. **連線建立**:
     - 建立 socket (`socket()`)
     - 設定伺服器位址
     - 連線到伺服器 (`connect()`)
  
  2. **執行緒啟動**:
     - 建立接收執行緒 (`pthread_create()`)
     - 接收執行緒開始監聽伺服器訊息
  
  3. **使用者輸入處理迴圈**:
     - 使用 `fgets()` 讀取使用者輸入
     - 移除換行符號 (`strcspn()`)
     - 檢查是否為 `EXIT!` 指令
     - 使用 `send()` 發送訊息到伺服器
  
  4. **清理階段**:
     - 發送 `EXIT!` 到伺服器
     - 關閉 socket
     - 取消並等待接收執行緒結束

#### 雙執行緒架構
- **主執行緒**: 處理使用者輸入和訊息發送
- **接收執行緒**: 持續監聽伺服器訊息並顯示
- 使用 `pthread_cancel()` 和 `pthread_join()` 安全地終止接收執行緒

### 訊息流程圖

```
客戶端A (RoomA) ──┐
                  ├── 伺服器 ── 廣播 ── 客戶端B (RoomA)
客戶端C (RoomB) ──┘              │
                                  └── 客戶端D (RoomB)
```

### 執行緒同步機制

**伺服器端同步**:
- 所有對 `client_sockets[]` 和 `client_rooms[]` 的存取都使用互斥鎖保護
- 確保廣播函數的原子性操作
- 避免多個執行緒同時修改共享資料

**客戶端同步**:
- 主執行緒和接收執行緒分別處理不同任務
- 使用 `pthread_cancel()` 安全地終止接收執行緒
- 確保程式結束時所有資源都被正確釋放

### 錯誤處理機制

#### 伺服器端錯誤處理
1. **Socket 建立失敗**:
   ```c
   if (server_fd < 0) {
       perror("Socket failed");
       exit(1);
   }
   ```

2. **Bind 失敗**:
   ```c
   if (bind(server_fd, ...) < 0) {
       perror("Bind failed");
       close(server_fd);
       exit(1);
   }
   ```

3. **客戶端斷線檢測**:
   ```c
   int len = recv(sock, buffer, sizeof(buffer), 0);
   if (len <= 0) break; // 客戶端斷線
   ```

4. **無效聊天室處理**:
   ```c
   if (roomLetter != 'A' && roomLetter != 'B' && roomLetter != 'C') {
       send(sock, "Invalid room! Use A, B, or C.\n", 30, 0);
       continue;
   }
   ```

#### 客戶端錯誤處理
1. **連線失敗**:
   ```c
   if (connect(sock, ...) < 0) {
       perror("Connection failed");
       close(sock);
       return 1;
   }
   ```

2. **接收執行緒異常終止**:
   ```c
   int len = recv(sock, msg, sizeof(msg) - 1, 0);
   if (len <= 0) break; // 連線中斷
   ```

### 記憶體管理

#### 伺服器端記憶體管理
- **動態執行緒建立**: 每個客戶端連線建立一個新的執行緒
- **執行緒分離**: 使用 `pthread_detach()` 避免記憶體洩漏
- **資源清理**: 客戶端斷線時自動清理 socket 和陣列記錄
- **互斥鎖銷毀**: 程式結束時使用 `pthread_mutex_destroy()`

#### 客戶端記憶體管理
- **執行緒取消**: 使用 `pthread_cancel()` 和 `pthread_join()` 安全終止執行緒
- **Socket 關閉**: 確保所有 socket 都被正確關閉
- **緩衝區管理**: 使用 `memset()` 清空緩衝區避免資料殘留

### 效能優化設計

1. **非阻塞式設計**: 每個客戶端使用獨立執行緒，避免相互阻塞
2. **最小鎖定時間**: 只在必要時使用互斥鎖，減少競爭
3. **緩衝區重用**: 重複使用固定大小的緩衝區
4. **執行緒池概念**: 雖然未實作執行緒池，但使用執行緒分離避免資源累積

### 程式碼架構優點

1. **模組化設計**: 每個函數職責明確，易於維護
2. **執行緒安全**: 完善的同步機制確保資料一致性
3. **錯誤恢復**: 良好的錯誤處理機制，程式穩定性高
4. **資源管理**: 適當的資源分配和釋放，避免記憶體洩漏
5. **擴展性**: 架構設計允許輕鬆擴展功能（如增加更多聊天室）

## 系統需求

- Linux 作業系統
- GCC 編譯器
- pthread 函式庫支援

## 注意事項

1. 確保防火牆允許 8080 埠的連線
2. 伺服器必須先啟動，客戶端才能連線
3. 使用 `Ctrl+C` 可以強制終止程式
4. 客戶端斷線後，伺服器會自動清理相關資源

## 範例執行流程

1. 啟動伺服器：`./server`
2. 啟動第一個客戶端：`./client`
3. 輸入 `enter A` 加入 RoomA
4. 啟動第二個客戶端：`./client`
5. 第二個客戶端也會自動加入 RoomA
6. 兩個客戶端現在可以在 RoomA 中聊天
7. 輸入 `EXIT!` 可以離開聊天室

這個系統完全符合作業要求，提供了完整的多執行緒 TCP 聊天室功能。
